* ACDc - Your friendly automatic call distribution commander

First, the "commander" part is a stretch, I know.

High level concepts involved here are queues and agents. There's a many-many relationship between queues and agents: a queue can have many agents, and an agent can be part of many queues. As such, there needs to be a distinct differentiation between what an agent is responsible for and what a queue tracks.

** Agents

An agent represents an account user with a device (and possibly many devices). The agent tracks:

1. what state it is in (and whether it can bridge member calls to the device)
2. when it last had a call (some queue types are interested)
3. the endpoint(s) to bridge a member's call to
4. the current call (if agent is engaged by a member)
5. the agent id
6. the agent's account db

*** Agent Statuses

*init*: the agent process is starting up. Will not accept member connection requests. Waits for agent status event to know what state to transition to out of init.

*ready*: the agent process is awaiting member connection requests.

*waiting*: the agent process has responded to a member connection request. This state will end either by timeout or member connection win.

*ringing*: the agent process has received a member connection win and is currently dialing the agent's device.

*answered*: the agent device has successfully bridged to the member. Waiting for the call to hangup.

*wrapup*: configurable wait time after a call has ended before the agent is ready to accept another call.

*paused*: the agent is on break or otherwise not taking calls. An optional timer can be set to limit how long the agent may remain in the paused state. Also the state where the agent process goes when "logging out" for the night/weekend/what-have-you.

*** Happy case for a member call

agent status: *ready*
Agent process receives a member_connect_req message off the message bus. Agent publishes a member_connect_resp to the requesting queue's AMQP queue and enters the *waiting* state.

agent status: *waiting*
Agent process receives member_connect_win, including the whapps_call json payload. Agent process publishes a bridge_req to the call control process. Agent publishes agent_state_change to other agent processes monitoring this agent_id. Agent process enters the *ringing* state.

agent status: *ringing*
Agent process receives (eventually) the successful bridge event. Agent enters the *answered* state. Send the queue a member_connected message.

agent status: *answered*
Agent process monitors the call's event stream, waiting for a hangup event. Upon reception, enter the *wrapup* state.

agent status: *wrapup*
Queue may optionally specify a wrapup_timeout, delaying how long an agent must wait before returning to *ready*.

** Queues

Queues manage the dispersal of member calls to agents. Because the queue won't know if an agent is busy in another queue, the queue will broadcast a member_connect_req to all known agents. The queue will collect member_connect_resps and choose one agent, based on routing strategy, to send the member_connect_win message. If the agent is unable to connect the call and send the queue a member_connected, the agent will attempt the next appropriate member_connect_resp. If the list is exhausted, the queue will wait a configurable amount of time before sending another member_connect_req and repeating the process.

